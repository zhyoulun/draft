当人们谈论索引的时候，如果没有特别指明类型，那多半说的是B-Tree数据结构来存储数据。索引，它使用B-Tree数据结构来存储数据。大多数MySQL引擎都支持这种索引。

实际上，很多存储引擎使用的是B+Tree，这是B Tree的一个变种，即每一个叶子节点，都包含指向下一个叶子节点的指针，从而更方便叶子节点的范围遍历。

存储引擎以不同的方式使用B-Tree索引，性能各有不同，各有优劣。例如，MyISAM使用前缀压缩技术使得索引更小，但InnoDB则按照原数据格式存储。再如MyISAM索引通过数据的物理位置引用被索引的行，而InnoDB则根据主键引用被索引的行。

B-Tree通常意味着所有的值是按照顺序存储的，并且每一个叶子页到根的距离相同。下图展示了B-Tree索引的抽象表示，大致反映了InnoDB索引是如何工作的。MyISAM使用的结构有所不同，但基本思想是类似的。

![](http://mdimg.fabuler.cn/1707/p101.png)

B-Tree索引能够加快访问数据的速度，因为存储引擎不在需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。根节点的槽存放了指向子节点的指针，存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值，可以找到合适的指针进入下层子节点，这些指针实际上定义了子节点页中值的上限和下限。最终存储引擎要么找到对应的值，要么该记录不存在。

叶子节点比较特别，他们的指针指向的是被索引的数据，而不是其它的节点页（不同的引擎的指针类型不同）。

上图仅绘制了一个节点和其对应的叶子节点，其实在根节点的叶子节点之间可能有很多层节点页。树的深度和表的大小直接相关。

B-Tree对索引列是顺序组织存储的，所以很适合查找范围数据。例如，在一个基于文本域的索引树上，按字母顺序传递连续的值进行查找是非常合适的，所以像“找出所有以I到K开头的名字”这样的查找效率会非常高。

假如有如下数据表：

```
create table people(
    last_name varchar(50) not null,
    first_name varchar(50) not null,
    dob date not null,
    gender enum('m','f') not null,
    key(last_name, first_name, dob)
);
```

对于表中的每一行数据，索引中包含了last_name、first_name和dob列的值，下图显示了该索引是如何组织数据的存储的。

![](http://mdimg.fabuler.cn/1707/p102.png)

请注意，索引对多个值进行排序的依据是CREATE TABLE语句中定义索引时列的排序。看一下最后两个条目，两个人的姓和名是一样的，则根据他们的出生日期来排列。

## 可以使用B-Tree索引的查询类型

B-Tree索引适用于全键值、键值范围或者键前缀查找。其中键前缀查找只适用于根据最左前缀的查找。前面所述的索引对如下类型的查询有效。

- 全值匹配

全值匹配指的是和索引中所有的列进行匹配，例如前面提到的索引可用于查找姓名为Cuba Allen、出生于1960-01-01的人。

- 匹配最左前缀

前面提到的索引可用于查找所有姓为Allen的人，即只使用索引的第一列。

- 匹配列前缀

也可以只匹配某一列的值的开头部分。例如前面提到的索引可用于查找所有以J开头的姓的人。这里也只使用了索引的第一列。

- 匹配范围值

例如前面提到的索引可用于查找姓在Allen和Barrymore之间的人。这里也只使用了索引的第一列。

- 精确匹配某一列并范围匹配另外一列

前面提到的索引也可以用于查找所有行为Allen，并且名字是字母K开头（比如Kim、Karl等）的人。即第一列last_name全匹配，第二列first_name范围匹配。

- 只访问索引的查询

B-Tree通常可以支持“只访问索引的查询”，即查询只需要访问索引，而无需访问数据行。

因为索引树种的节点是有序的，所以出了按值查找以外，索引还可以用于查询中的order by操作（按顺序查找）。一般来说，如果B-Tree可以按照某种方式查找到值，那么也可以按照这种方式用于排序。所以，如果order by字句满足前面列出的几种查询类型，则这个索引也可以满足对应的排序需求。

## B-Tree索引的限制

- 如果不是按照索引的最左列开始查找，则无法使用索引。例如上面例子中的索引无法用于查找名字为bill的人，也无法查找某个特定生日的人，因为这两列都不是最左数据列。类似地，也无法查找姓氏以某个字母结尾的人。
- 不能跳过索引中的列。也就是说，前面所述的索引无法用于查找行为Smith并且在某个特定生日出生的人。如果不指定名（first_name），则MySQL只能使用索引的第一列。
- 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查询。例如有查询where last_name='smith' and first_name like 'j' and dob='1976-12-23'，这个查询只能使用索引的前两列，因为这里like是一个范围条件。如果范围查询列值的数量有限，那么可以通过使用多个等于条件来代替范围条件。


## 参考

- 来自《高性能MySQL》
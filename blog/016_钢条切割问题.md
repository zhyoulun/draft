## 问题

给定一段长度为@$n@$的钢条，和一个价格表@$p_i(i=1,2,\cdots,n)@$，求切割钢条的方案，是得销售收益@$r_n@$最大。

长度为@$n@$的钢条共有@$2^{n-1}@$种不同的切割方案，因为长度为@$n@$的钢条共有@$n-1@$个切割点，对于每一个点我们总是可以选择切割或者不切割。

如果一个最优解将钢条切割为@$k@$段（对某个@$1 \leq k \leq n@$），那么最优切割方案：

$$n=i_1+i_2+\cdots+i_k$$

将钢条切割为长度分别为$$i_1, i_2, \cdots, i_k$$的小段，得到最大收益：

$$r\_n=p\_{i\_1}+p\_{i\_2}+\cdots+p\_{i\_k}$$

递归求解方法：将钢条从左边切割下长度为@$i@$的一段，只对右边剩下的长度为@$n-i@$的一段继续进行切割（递归求解），对左边的一段则不再进行切割。即问题分解的方式为：将长度为@$n@$的钢条分解为左边开始一段，以及剩余部分继续分解的结果。这样，不做任何切割的方案就可以描述为：第一段的长度为@$n@$，收益为@$p_n@$，剩余部分长度为@$0@$，对应的收益为@$r_0=0@$。于是我们可以得到如下公式：

$$r\_n=max\_{1 \leq i \leq n}(p\_i+r\_{n-i})$$

## 解法

### 自顶向下递归实现

```
package main

import "fmt"

func main() {
	p := []int{1, 5, 8, 9, 10, 17, 17, 20, 24, 30}

	for i:=1;i<=10;i++{
		fmt.Println(i,cut_rod(p, i))
	}
}

func cut_rod(p []int, n int) (q int) {
	if n == 0 {
		q = 0
		return
	}
	q = -1
	for i := 0; i < n; i++ {
		temp := p[i] + cut_rod(p, n - 1 - i)
		if q < temp {
			q = temp
		}
	}
	return
}
```

### 使用动态规划方法求解最优钢条切割问题

动态规划方法的思想如下所述。我们已经看到，朴素的递归算法之所以效率很低，是因为反复求解相同的子问题。因此，动态规划方法仔细安排求解顺序，对每个子问题只求解一次，并将结果保存下来。如果随后再次需要此问题的解，只需要查找保存的结果，而不必重新计算。

因此，动态规划方法是付出额外的内存空间来节省计算时间，是典型的时空权衡的例子。

动态规划有两种等价的实现方法，下面以钢条切割问题为例，展示这两种方法。

第一种方法称为带备忘的自顶向下法。此方法仍自然的递归形式编写过程，但过程会保存每个子问题的解（通常保存在一个数组或者散列表中）。当需要一个子问题的解时，过程首先检查是否已经保存过此解。如果是，则直接返回保存的值，从而节省了计算时间；否则，按通常方式计算这个问题。

第二种方法称为自底向上法。这种方法一般需要恰当定义子问题规模的概念，使得任何子问题的求解都只是依赖于更小的子问题的求解。因而我们可以将子问题按规模排序，按由小到大的顺序进行求解。当求解某个子问题时，它所依赖的那些更小的子问题都已经求解完毕，结果已经保存。每个子问题只需要求解一次，当我们求解它时，它的所有前提子问题都已经求解完成。

带备忘的自顶向下法.

```
package main

import "fmt"

func main() {
	p := []int{1, 5, 8, 9, 10, 17, 17, 20, 24, 30}

	for i := 1; i <= 10; i++ {
		fmt.Println(i, memorized_cut_rod(p, i))
	}
}

func memorized_cut_rod(p []int, n int) (q int) {
	r := make([]int, n + 1, n + 1)
	for i := 0; i <= n; i++ {
		r[i] = -1
	}
	q = memorized_cut_rod_aux(p, n, r)
	return
}

func memorized_cut_rod_aux(p []int, n int, r[]int) (q int) {
	if r[n] >= 0 {
		q = r[n]
		return
	}

	if n == 0 {
		q = 0
	} else {
		q = -1
		for i := 0; i < n; i++ {
			temp := p[i] + memorized_cut_rod_aux(p, n - 1 - i, r)
			if q < temp {
				q = temp
			}
		}
	}
	r[n] = q
	return
}
```

自底向上法

```
package main

import "fmt"

func main() {
	p := []int{1, 5, 8, 9, 10, 17, 17, 20, 24, 30}

	for i := 1; i <= 10; i++ {
		fmt.Println(i, bottom_up_cut_rod(p, i))
	}
}

func bottom_up_cut_rod(p []int, n int) (q int) {
	r := make([]int, n + 1, n + 1)
	r[0] = 0
	for j := 1; j <= n; j++ {
		q = -1
		for i := 0; i < j; i++ {
			temp := p[i] + r[j - i - 1]
			if q < temp {
				q = temp
			}
		}
		r[j] = q
	}
	q = r[n]
	return
}
```

## 参考

- 算法导论